"""
This type stub file was generated by pyright.
"""

def set_logging(rank=...): # -> None:
    ...

def init_seeds(seed=...): # -> None:
    ...

def get_latest_run(search_dir=...): # -> str:
    ...

def isdocker(): # -> bool:
    ...

def emojis(str=...): # -> str:
    ...

def check_online(): # -> bool:
    ...

def check_git_status(): # -> None:
    ...

def check_requirements(requirements=..., exclude=...): # -> None:
    ...

def check_img_size(img_size, s=...):
    ...

def check_imshow(): # -> bool:
    ...

def check_file(file):
    ...

def check_dataset(dict): # -> None:
    ...

def make_divisible(x, divisor):
    ...

def clean_str(s): # -> str:
    ...

def one_cycle(y1=..., y2=..., steps=...): # -> (x: Unknown) -> float:
    ...

def colorstr(*input): # -> str:
    ...

def labels_to_class_weights(labels, nc=...): # -> Tensor:
    ...

def labels_to_image_weights(labels, nc=..., class_weights=...): # -> Any:
    ...

def coco80_to_coco91_class(): # -> list[int]:
    ...

def xyxy2xywh(x): # -> Tensor | NDArray[Unknown]:
    ...

def xywh2xyxy(x): # -> Tensor | NDArray[Unknown]:
    ...

def xywhn2xyxy(x, w=..., h=..., padw=..., padh=...): # -> Tensor | NDArray[Unknown]:
    ...

def xyn2xy(x, w=..., h=..., padw=..., padh=...): # -> Tensor | NDArray[Unknown]:
    ...

def segment2box(segment, width=..., height=...): # -> NDArray[Unknown] | NDArray[float64]:
    ...

def segments2boxes(segments): # -> Tensor | NDArray[Unknown]:
    ...

def resample_segments(segments, n=...):
    ...

def scale_coords(img1_shape, coords, img0_shape, ratio_pad=...):
    ...

def clip_coords(boxes, img_shape): # -> None:
    ...

def bbox_iou(box1, box2, x1y1x2y2=..., GIoU=..., DIoU=..., CIoU=..., eps=...): # -> None:
    ...

def bbox_alpha_iou(box1, box2, x1y1x2y2=..., GIoU=..., DIoU=..., CIoU=..., alpha=..., eps=...): # -> Tensor | None:
    ...

def box_iou(box1, box2):
    """
    Return intersection-over-union (Jaccard index) of boxes.
    Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
    Arguments:
        box1 (Tensor[N, 4])
        box2 (Tensor[M, 4])
    Returns:
        iou (Tensor[N, M]): the NxM matrix containing the pairwise
            IoU values for every element in boxes1 and boxes2
    """
    ...

def wh_iou(wh1, wh2):
    ...

def box_giou(box1, box2):
    """
    Return generalized intersection-over-union (Jaccard index) between two sets of boxes.
    Both sets of boxes are expected to be in ``(x1, y1, x2, y2)`` format with
    ``0 <= x1 < x2`` and ``0 <= y1 < y2``.
    Args:
        boxes1 (Tensor[N, 4]): first set of boxes
        boxes2 (Tensor[M, 4]): second set of boxes
    Returns:
        Tensor[N, M]: the NxM matrix containing the pairwise generalized IoU values
        for every element in boxes1 and boxes2
    """
    ...

def box_ciou(box1, box2, eps: float = ...):
    """
    Return complete intersection-over-union (Jaccard index) between two sets of boxes.
    Both sets of boxes are expected to be in ``(x1, y1, x2, y2)`` format with
    ``0 <= x1 < x2`` and ``0 <= y1 < y2``.
    Args:
        boxes1 (Tensor[N, 4]): first set of boxes
        boxes2 (Tensor[M, 4]): second set of boxes
        eps (float, optional): small number to prevent division by zero. Default: 1e-7
    Returns:
        Tensor[N, M]: the NxM matrix containing the pairwise complete IoU values
        for every element in boxes1 and boxes2
    """
    ...

def box_diou(box1, box2, eps: float = ...):
    """
    Return distance intersection-over-union (Jaccard index) between two sets of boxes.
    Both sets of boxes are expected to be in ``(x1, y1, x2, y2)`` format with
    ``0 <= x1 < x2`` and ``0 <= y1 < y2``.
    Args:
        boxes1 (Tensor[N, 4]): first set of boxes
        boxes2 (Tensor[M, 4]): second set of boxes
        eps (float, optional): small number to prevent division by zero. Default: 1e-7
    Returns:
        Tensor[N, M]: the NxM matrix containing the pairwise distance IoU values
        for every element in boxes1 and boxes2
    """
    ...

def non_max_suppression(prediction, conf_thres=..., iou_thres=..., classes=..., agnostic=..., multi_label=..., labels=...):
    """Runs Non-Maximum Suppression (NMS) on inference results

    Returns:
         list of detections, on (n,6) tensor per image [xyxy, conf, cls]
    """
    ...

def non_max_suppression_kpt(prediction, conf_thres=..., iou_thres=..., classes=..., agnostic=..., multi_label=..., labels=..., kpt_label=..., nc=..., nkpt=...):
    """Runs Non-Maximum Suppression (NMS) on inference results

    Returns:
         list of detections, on (n,6) tensor per image [xyxy, conf, cls]
    """
    ...

def strip_optimizer(f=..., s=...): # -> None:
    ...

def print_mutation(hyp, results, yaml_file=..., bucket=...): # -> None:
    ...

def apply_classifier(x, model, img, im0):
    ...

def increment_path(path, exist_ok=..., sep=...): # -> str:
    ...

